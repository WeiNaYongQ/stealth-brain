<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Calculator</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent;user-select:none;}
body,html{height:100%;background:#000;color:#fff;font-family:sans-serif;overflow:hidden;}
#calculator{display:flex;flex-direction:column;height:100%;padding:20px 0 0;}
#display{padding:0 20px 20px;text-align:right;font-size:80px;min-height:120px;display:flex;align-items:flex-end;justify-content:flex-end;overflow:hidden;white-space:nowrap;}
#buttons{display:grid;grid-template-columns:repeat(4,1fr);grid-template-rows:repeat(5,1fr);gap:16px;padding:0 16px 24px;flex:1;}
.btn{background:#333;border-radius:50%;font-size:32px;display:flex;align-items:center;justify-content:center;color:#fff;border:none;cursor:pointer;}
.btn:active{background:#444;}
.btn.operator{background:#f1a33c;}
.btn.operator:active{background:#d99234;}
.btn.zero{grid-column:span 2;border-radius:36px;}
#chessLayer{position:absolute;top:0;left:0;width:100%;height:100%;background:#000;opacity:0;pointer-events:none;}
</style>
</head>
<body>
<div id="calculator">
<div id="display">0</div>
<div id="buttons">
<button class="btn clear" data-value="C">C</button>
<button class="btn" data-value="±">±</button>
<button class="btn" data-value="%">%</button>
<button class="btn operator" data-value="/">÷</button>
<button class="btn" data-value="7">7</button>
<button class="btn" data-value="8">8</button>
<button class="btn" data-value="9">9</button>
<button class="btn operator" data-value="*">×</button>
<button class="btn" data-value="4">4</button>
<button class="btn" data-value="5">5</button>
<button class="btn" data-value="6">6</button>
<button class="btn operator" data-value="-">−</button>
<button class="btn" data-value="1">1</button>
<button class="btn" data-value="2">2</button>
<button class="btn" data-value="3">3</button>
<button class="btn operator" data-value="+">+</button>
<button class="btn zero" data-value="0">0</button>
<button class="btn" data-value=".">.</button>
<button class="btn" data-value="=">=</button>
</div>
</div>
<div id="chessLayer"></div>
<script src="https://cdn.jsdelivr.net/npm/chess.js@0.10.3/chess.min.js"></script>
<script>
let mode = 'calculator';
let file = 0, rank = 1;
let game = new Chess();
let fromSquare = null;
let lastBestMove = null;
let moveHistory = [];

const calcEl = document.getElementById('calculator');
const chessEl = document.getElementById('chessLayer');
const display = document.getElementById('display');

const vibrate = (ms) => {
  if (navigator.vibrate) navigator.vibrate(ms);
};

const speak = (text) => {
  if (!speechSynthesis) return;
  speechSynthesis.cancel();
  const u = new SpeechSynthesisUtterance(text);
  u.rate = 1.3;
  u.volume = 1.0;
  u.lang = 'en-US';
  speechSynthesis.speak(u);
};

const getCoord = () => String.fromCharCode(97 + file) + rank;

const switchToChess = (color) => {
  mode = 'chess';
  calcEl.style.display = 'none';
  chessEl.style.opacity = '1';
  chessEl.style.pointerEvents = 'auto';
  file = 0; rank = 1; fromSquare = null; lastBestMove = null; moveHistory = []; game = new Chess();
  if (color === 'black') setTimeout(fetchBestMove, 500);
  else speak("White to move");
};

const switchToCalculator = () => {
  mode = 'calculator';
  calcEl.style.display = 'flex';
  chessEl.style.opacity = '0';
  chessEl.style.pointerEvents = 'none';
  speechSynthesis.cancel();
  currentInput = '0';
  operatorPressed = false;
  updateDisplay();
};

// ✅ STRONG ENGINE — FIXED URL + SMART FALLBACK
const fetchBestMove = async () => {
  speak("Thinking");
  
  // Try chess.swehosting.se (FIXED URL — no extra spaces)
  try {
    const res = await fetch('https://chess.swehosting.se/api/v1/', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ fen: game.fen(), depth: 15 })
    });
    if (res.ok) {
      const data = await res.json();
      const bestMove = data.bestmove;
      if (bestMove?.length === 4) {
        const from = bestMove.slice(0, 2);
        const to = bestMove.slice(2, 4);
        const move = game.move({ from, to, promotion: 'q' });
        if (move) {
          lastBestMove = { from, to };
          speak(`Opponent ${from} to ${to}`);
          vibrate(50);
          file = 0; rank = 1;
          return;
        }
      }
    }
  } catch (e) {}

  // Fallback: Lichess Cloud Eval
  try {
    const fen = game.fen().replace(/\s+/g, '_');
    const url = `https://lichess.org/api/cloud-eval?fen=${fen}&multiPv=3`;
    const res = await fetch(url);
    if (res.ok) {
      const data = await res.json();
      if (data.pvs?.[0]?.moves) {
        const firstMove = data.pvs[0].moves.split(' ')[0];
        if (firstMove?.length === 4) {
          const from = firstMove.slice(0, 2);
          const to = firstMove.slice(2, 4);
          const move = game.move({ from, to, promotion: 'q' });
          if (move) {
            lastBestMove = { from, to };
            speak(`Opponent ${from} to ${to}`);
            vibrate(50);
            file = 0; rank = 1;
            return;
          }
        }
      }
    }
  } catch (e) {}

  // Final fallback: SMART random move (avoid a1a2)
  const moves = game.moves({ verbose: true });
  if (moves.length === 0) return;

  const scored = moves.map(m => {
    let score = 0;
    const toFile = m.to.charCodeAt(0) - 97; // 0-7
    const toRank = parseInt(m.to[1]);
    // Bonus for center
    if (toFile >= 2 && toFile <= 5 && toRank >= 3 && toRank <= 6) score += 3;
    // Bonus for developing minor pieces
    if (m.piece === 'n' || m.piece === 'b') score += 2;
    // Penalty for edge pawn pushes
    if ((m.from === 'a2' || m.from === 'h2' || m.from === 'a7' || m.from === 'h7') && m.piece === 'p') score -= 5;
    return { move: m, score };
  });

  scored.sort((a, b) => b.score - a.score);
  const topMoves = scored.slice(0, Math.min(3, scored.length));
  const chosen = topMoves[Math.floor(Math.random() * topMoves.length)];

  game.move(chosen.move);
  lastBestMove = { from: chosen.move.from, to: chosen.move.to };
  speak(`Opponent ${chosen.move.from} to ${chosen.move.to}`);
  vibrate(50);
  file = 0; rank = 1;
};

let touchStartY = 0;
let longPressTimer = null;
let wasLongPress = false;

const handleTouchStart = (clientY) => {
  if (mode !== 'chess') return;
  touchStartY = clientY;
  wasLongPress = false;
  
  if (longPressTimer) clearTimeout(longPressTimer);
  
  // ✅ Speak coordinate IMMEDIATELY on touch
  speak(getCoord());
  vibrate(10);
  
  longPressTimer = setTimeout(() => {
    wasLongPress = true;
    const isUpper = touchStartY < window.innerHeight / 2;
    if (isUpper) {
      // Long-hold UPPER: Undo
      if (moveHistory.length > 0) {
        moveHistory.pop();
        const last = moveHistory[moveHistory.length - 1];
        game = new Chess(last ? last.fen : 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1');
        speak("Undone");
        vibrate(50);
        file = 0; rank = 1;
      } else {
        speak("No move");
      }
    } else {
      // Long-hold LOWER: Analysis
      if (lastBestMove) {
        speak(`Best move: ${lastBestMove.from} to ${lastBestMove.to}`);
      } else {
        speak("No analysis");
      }
    }
  }, 1200);
};

const handleTouchEnd = (clientY) => {
  if (mode !== 'chess') return;
  
  if (longPressTimer) {
    clearTimeout(longPressTimer);
    longPressTimer = null;
    
    if (!wasLongPress) {
      // Short tap: cycle
      const isUpper = clientY < window.innerHeight / 2;
      if (isUpper) rank = rank % 8 + 1;
      else file = (file + 1) % 8;
      
      // Speak new coordinate
      speak(getCoord());
      vibrate(10);
    } else {
      // Short hold (not long): set "From" or confirm
      const isUpper = touchStartY < window.innerHeight / 2;
      if (isUpper) {
        // Confirm move
        if (fromSquare) {
          const toSq = getCoord();
          const move = game.move({ from: fromSquare, to: toSq, promotion: 'q' });
          if (move) {
            moveHistory.push({ fen: game.fen() });
            speak(`To ${toSq}`);
            vibrate(50);
            fromSquare = null;
            file = 0; rank = 1;
            if (game.turn() === 'b') setTimeout(fetchBestMove, 300);
          } else {
            speak("Invalid");
            vibrate(10);
          }
        } else {
          speak("No from");
          vibrate(10);
        }
      } else {
        // Set "From"
        fromSquare = getCoord();
        speak(`From ${fromSquare}`);
        vibrate(50);
      }
    }
  }
};

chessEl.addEventListener('touchstart', (e) => {
  e.preventDefault();
  handleTouchStart(e.touches[0].clientY);
});

chessEl.addEventListener('touchend', (e) => {
  e.preventDefault();
  handleTouchEnd(e.changedTouches[0].clientY);
});

chessEl.addEventListener('touchcancel', () => {
  if (longPressTimer) clearTimeout(longPressTimer);
  longPressTimer = null;
  wasLongPress = false;
});

// CALCULATOR
let currentInput = '0';
let operatorPressed = false;
const updateDisplay = () => {
  display.textContent = currentInput.length > 12 ? parseFloat(currentInput).toExponential(5) : currentInput;
};
const handleButton = (v) => {
  if (v === 'C') { currentInput = '0'; operatorPressed = false; updateDisplay(); return; }
  if (v === '=') {
    if (currentInput === '666') { switchToChess('white'); return; }
    if (currentInput === '999') { switchToChess('black'); return; }
  }
  if (v === '±') { if (currentInput !== '0') currentInput = currentInput.startsWith('-') ? currentInput.slice(1) : '-' + currentInput; updateDisplay(); return; }
  if (v === '%') { const n = parseFloat(currentInput); if (!isNaN(n)) currentInput = (n/100).toString(); updateDisplay(); return; }
  if (['+','-','*','/'].includes(v)) {
    if (operatorPressed && ['+','-','*','/'].includes(currentInput.slice(-1))) currentInput = currentInput.slice(0,-1) + v;
    else currentInput += v; operatorPressed = true; updateDisplay(); return;
  }
  if (operatorPressed || currentInput === '0') { currentInput = v==='.'?'0.':v; operatorPressed = false; }
  else { if (v === '.') { if (!currentInput.includes('.')) currentInput += '.'; } else currentInput += v; }
  updateDisplay();
};
document.querySelectorAll('.btn').forEach(btn => btn.addEventListener('click', () => handleButton(btn.dataset.value)));
updateDisplay();
</script>
</body>
</html>
